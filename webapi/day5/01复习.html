<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
    
    /* 
        为元素绑定事件的三种方式:   
        1.
        对象.on事件类型=事件处理函数;
        2.IE8不支持
        对象.addEventListener("没有on的事件类型",事件处理函数,false);
        3.谷歌和火狐不支持
        对象.attachEvent("有on的事件类型",事件处理函数);

        为元素解绑事件的三种方式:
        1.
        对象.on事件类型=null;
        2.IE8不支持
        对象.removeEventListener("没有on的事件类型",事件处理函数,false);
        3.谷歌火狐不支持
        对象.detachEvent("有on的事件类型",事件处理函数);

        事件冒泡:元素A中有元素B,都有相同的事件,里面的元素的事件触发了，外面元素的事件也会触发,可以是多个元素嵌套

        阻止事件冒泡:
        1.
        谷歌和火狐都支持,IE8不支持
        e.stopPropagation(); e---事件参数对象,
        2.
        IE8和谷歌支持，火狐不支持
        window.event.cancelBubble=true;

        window.event就是事件参数对象----e是一样的

        BOM: Browser Object Model 浏览器对象模型---操作浏览器
        历史记录的后退和前进 history: back() forward()前进


        地址栏上#及后面的内容
        console.log(window.location.hash);
        主机名及端口号
        console.log(window.location.host);
        主机名
        console.log(window.location.hostname);
        文件的路径---相对路径
        console.log(window.location.pathname);
        端口号
        console.log(window.location.port);
        协议
        console.log(window.location.protocol);
        搜索的内容
        console.log(window.location.search);

        定时器: 
        该定时器会返回自己的id值
        var timeId=setInterval(函数,时间);
        执行过程: 页面加载完毕后,过了一段时间执行函数,反复的,除非清理定时器
        window.clearInterval(定时器的id值);清理定时器
    */

    </script>
</head>
<body>
    
</body>
</html>